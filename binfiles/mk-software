#!/usr/bin/env zsh

# This is a generic build script to download the latest source code and
# build a new version of a software package.  This script knows how to
# build various packages; see the definition of all_packages below.

emulate -LR zsh

# Install alacritty.
function
alacrittyInstall()
{
  case $(uname -a) in
  (*deb*)
    # Installs in /usr/local/bin/alacritty
    cargo deb --install
    mv /usr/local/bin/alacritty $USRLOCAL/bin
    ;;
  (*arch*)
    cp target/release/alacritty $USRLOCAL/bin
    sudo desktop-file-install alacritty.desktop
    sudo update-desktop-database
    ;;
  esac
}

# The emacs pre-configure command is autogen.sh.
function
emacsPreConfigure()
{
  (
    cd $1
    (
      ./autogen.sh
      ./autogen.sh autoconf
    ) >& autogen.out

    if [[ -e $SCMROOT/rust-mode ]]; then
      cd lisp
      ln -s $SCMROOT/rust-mode/rust-mode.el
    fi
  )
}

# The i3 pre-configure command is autoreconf.
function
i3PreConfigure()
{
  (
    cd $1
    autoreconf -fi
  )
}

# After building kitty, copy and tweak the configuration.
function
kittyPostInstall()
{
  conf_dir=~/.config/kitty
  mkdir -p $conf_dir
  (
    cp $1/docs/generated/conf/kitty.conf $conf_dir
    cd $conf_dir
    unset conf_dir
    patch --backup <<EOF
--- kitty.conf.orig	2019-04-24 16:50:04.007290415 -0400
+++ kitty.conf	2019-04-24 17:06:35.009755308 -0400
@@ -6,7 +6,7 @@
 #: individual font faces and even specify special fonts for particular
 #: characters.
 
-font_family      monospace
+font_family      hack
 bold_font        auto
 italic_font      auto
 bold_italic_font auto
@@ -97,7 +97,7 @@
 
 #: Scrollback {{{
 
-scrollback_lines 2000
+scrollback_lines 10000
 
 #: Number of lines of history to keep in memory for scrolling back.
 #: Memory is allocated on demand. Negative numbers are (effectively)
@@ -413,12 +413,12 @@
 
 #: Color scheme {{{
 
-foreground #dddddd
-background #000000
+foreground #839496
+background #002b36
 
 #: The foreground and background colors
 
-background_opacity 1.0
+background_opacity 0.92
 
 #: The opacity of the background. A number between 0 and 1, where 1 is
 #: opaque and 0 is fully transparent.  This will only work if
@@ -505,7 +505,7 @@
 
 #: Advanced {{{
 
-shell .
+shell /opt/bin/zsh -l
 
 #: The shell program to execute. The default value of . means to use
 #: whatever shell is set as the default shell for the current user.
@@ -513,7 +513,7 @@
 #: --login to ensure that the shell starts in interactive mode and
 #: reads its startup rc files.
 
-editor .
+editor /opt/bin/emacsclient -q
 
 #: The console editor to use when editing the kitty config file or
 #: similar tasks. A value of . means to use the environment variable
@@ -711,7 +711,7 @@
 
 #:     map ctrl+f>2 set_font_size 20
 
-kitty_mod ctrl+shift
+kitty_mod ctrl+shift+alt
 
 #: The value of kitty_mod is used as the modifier for all default
 #: shortcuts, you can change it in your kitty.conf to change the
@@ -765,7 +765,7 @@
 #: example, the following opens the scrollback buffer in less in an
 #: overlay window::
 
-#:     map f1 pipe @ansi overlay less +G -R
+map kitty_mod+f1 pipe @ansi os_window less +G -R
 
 #: For more details on piping screen and buffer contents to external
 #: programs, see pipe.
EOF
  )
}

# The zsh pre-configure command is built in to the zsh sources.
function
zshPreConfigure()
{
  (
    cd $1
    ./Util/preconfig
  )
}

# Make a suitable build directory under $BLDROOT and cd to it.
function
CreateBuildDirectory()
{
  ver=${1#$SRCROOT/}
  mkdir $BLDROOT/$ver
  cd $BLDROOT/$ver
}

function
Help() {
  print -n -u2 "usage:
$progname <package> "
  for f in ${(ki)abbrevs}; do
    print -n -u2 "[-$f|-${abbrevs[$f]}] "
  done
  print -u2
  for f in ${(ki)abbrevs}; do
    print -u2 "    -${f}${desc[$f]}"
  done
  print -u2 "    <package> is one of: $(PrintList ${(ki)all_packages})."
}

# Update the symbolic link pointing to the most recent copy
# of the specified package.
function
LinkLatest()
{
  cd $USRLOCAL
  package=$1
  rm $package || return $?
  ln -s ${package}*(oc[1]) $package
}

# Print a list of things to stdout.
function PrintList() {
  while (( $# > 0 ))
  do
    print -n "$1"
    shift
    if [[ $# -gt 1 ]]; then
      print -n ", "
    elif [[ $# -eq 1 ]]; then
      print -n " and "
    fi
  done
}

: ${USRLOCAL:=/usr/local}
: ${BLDROOT:=$USRLOCAL/build}
: ${SRCROOT:=$USRLOCAL/src}

export PREFIX=$USRLOCAL

# Get the program name from arg0.
progname=${0:t}

# Add a new package here.
typeset -AA all_packages=(
  alacritty 1
  bzip2     1
  conky     1
  emacs     1
  exa       1
  feh       1
  i3        1
  kitty     1
  perl      1
  ripgrep   1
  tigervnc  1
  tilda     1
  zsh       1
)

# Add each new option here.
typeset -AA abbrevs desc val
force_opt=
abbrevs[-force]=f
   desc[-force]="     Build the package even if nothing has changed"
    val[-force]=force_opt

help_opt=
abbrevs[-help]=h
   desc[-help]="      Print this help message and exit"
    val[-help]=help_opt

install_opt=
abbrevs[-install]=i
   desc[-install]="   Install the package after building it"
    val[-install]=install_opt

snapshot_opt=
abbrevs[-snapshot]=s
   desc[-snapshot]="  Build the package for a snapshot prefix (i.e. \"$USRLOCAL/<package>-$(today)\")"
    val[-snapshot]=snapshot_opt

tar_opt=
abbrevs[-tar]=t
   desc[-tar]="       Build the package from a tarball, ignoring SCM"
    val[-tar]=tar_opt

# Parse the options.
for f in ${(k)abbrevs}; do
  zparseopts -E -D $f=${val[$f]} ${abbrevs[$f]}=${val[$f]}
done

# print "force_opt=\"$force_opt\""
# print "help_opt=\"$help_opt\""
# print "install_opt=\"$install_opt\""
# print "snapshot_opt=\"$snapshot_opt\""
# print "tar_opt=\"$tar_opt\""

if [[ -n $help_opt ]]; then
  Help
  exit 0
fi

# The old style was to determine the package to build
# based on the command name, like "mk-perl".
# The new style is to pass the package name as the first parameter.
pkgname=${progname:s/mk-/}
if [[ $progname == mk-software ]]; then
  pkgname=$1
  shift
fi

# All packages potentially go through the same steps:
#  - Update source control
#  - Copy from source control
#  - configure
#  - make
#  - make test
#  - make install

if [[ -z ${all_packages[$pkgname]} ]]; then
  print -u2 "\
$progname: unknown package \"$pkgname\".
This script knows how to build \
$(PrintList ${(ki)all_packages})."
  exit 1
fi

# --tar option means use a tarball, not SCM.
scm_opts=()
[[ -n $tar_opt ]] || scm_opts+="--update"
[[ -n $force_opt ]] && scm_opts+="--force"

# Update the sources and copy them into a source directory.
srcdir=$(GetSource $scm_opts $pkgname) || exit $?

# alacritty, exa, feh and ripgrep lack real configuration mechanisms,
# so we build those packages in their source directories.
case $pkgname in
(alacritty)
  ;&  # Fall through
(exa)
  ;&  # Fall through
(feh)
  ;&  # Fall through
(ripgrep)
  cd $srcdir
  ;;

# Other packages support building in a separate directory
# and their package-specific recipes reflect that.
(*)
  CreateBuildDirectory $srcdir
  srcdir=$(relative $srcdir)
  ;;
esac

# Implement the --snapshot option.
[[ -n $snapshot_opt ]] && PREFIX=$PREFIX/${pkgname}-$(today)

# Set the default commands.
BUILD=( make )
CONFIGURE=()
INSTALL=( make install )
POSTINSTALL=()
[[ -n $snapshot_opt ]] && POSTINSTALL=( LinkLatest $pkgname )
PRECONFIGURE=()
TEST=()

case $pkgname in
(alacritty)
  BUILD=( make binary )
  INSTALL=( alacrittyInstall )
  ;;

(bzip2)
  CONFIGURE=( $srcdir/autogen.sh --prefix=$PREFIX )
  TEST=( make check )
  ;;

(conky)
  CONFIGURE=( cmake
              -DCMAKE_INSTALL_PREFIX=$PREFIX
              -DBUILD_XDBE=true
              $srcdir )
  ;;

(emacs)
  PRECONFIGURE=( emacsPreConfigure $srcdir )
  CONFIGURE=( $srcdir/configure
              --prefix=$PREFIX
              --without-selinux
              --without-compress-install
              $* )
  BUILD=( make CFLAGS=-O3 bootstrap )
  # TEST=( make -k check )
  ;;

(exa)
  export ZSHDIR=$USRLOCAL/zsh/share/zsh/site-functions
  BUILD=( make -e )
  INSTALL=( make -e install install-zsh-completions )
  ;;

(feh)
  export VERSION=$(today)
  BUILD=( make -e )
  INSTALL=( make -e install )
  ;;

(i3)
  PRECONFIGURE=( i3PreConfigure $srcdir )
  CONFIGURE=( $srcdir/configure
              --prefix=$PREFIX )
  ;;

(kitty)
  BUILD=( $srcdir/setup.py --prefix $PREFIX linux-package )
  TEST=( $srcdir/setup.py test )
  INSTALL=( kittyPostInstall $srcdir )
  ;;

(perl)
  CONFIGURE=( $srcdir/Configure
              -Dprefix=$PREFIX
              -Dusedevel
              -Dcf_email=ethersoft@gmail.com
              -Dmksymlinks
              -des )
  TEST=( make test )
  ;;

(ripgrep)
  BUILD=( cargo build --release --features 'pcre2' )
  INSTALL=( install -Dm755 target/release/rg $PREFIX/bin/rg )
  TEST=( cargo test --all )
  ;;

(tigervnc)
  CONFIGURE=( cmake
              -DCMAKE_INSTALL_PREFIX=$PREFIX
              $srcdir )
  ;;

(tilda)
  CONFIGURE=( $srcdir/autogen.sh --prefix=$PREFIX --enable-clang )
  ;;

(zsh)
  PRECONFIGURE=( zshPreConfigure $srcdir )
  CONFIGURE=( $srcdir/configure
              --prefix=$PREFIX
              --enable-pcre )
  TEST=( make -k check )
  INSTALL=( make install install.info )
  ;;
esac

# Number of lines to tail on an error.
: ${ERROR_LINES:=15}

if [[ -n $CONFIGURE ]]; then
  out=conf.out
  print -n "Configuring $pkgname ... "
  [[ -n $PRECONFIGURE ]] && ( $PRECONFIGURE ) >& /dev/null
  ( $CONFIGURE ) >& $out
  retval=$?
  print "done."
  if (( retval != 0 )); then
    print -u2 "$progname: configuration failed:"
    tail -n $ERROR_LINES $out >&2
  fi
fi

if (( retval == 0 )) && [[ -n $BUILD ]]; then
  out=mk.out
  print -n "Building $pkgname ... "
  ( $BUILD ) >& $out
  retval=$?
  print "done."
  if (( retval != 0 )); then
    print -u2 "$progname: building failed:"
    tail -n $ERROR_LINES $out >&2
  fi
fi

if  (( retval == 0 )) && [[ -n $TEST ]]; then
  out=check.out
  print -n "Testing $pkgname ... "
  ( $TEST ) >& $out
  retval=$?
  print "done."
  if (( retval != 0 )); then
    print -u2 "$progname: testing failed:"
    tail -n $ERROR_LINES $out >&2
  fi
fi

if (( retval == 0 )) && [[ -n $INSTALL ]] && [[ -n $install_opt ]]; then
  out=inst.out
  print -n "Installing $pkgname ... "
  ( $INSTALL ) >& $out
  retval=$?
  ( $POSTINSTALL ) >>& $out
  print "done."
  if (( retval != 0 )); then
    print -u2 "$progname: installation failed:"
    tail -n $ERROR_LINES $out >&2
  fi
fi

exit $retval

# Local Variables:
# mode: shell-script
# sh-basic-offset: 2
# sh-indentation: 2
# indent-tabs-mode: nil
# End:
